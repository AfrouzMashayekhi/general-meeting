"use strict";
/**
 * Copyright 2020 IBM All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TransactionStatus = require("./transactionstatus");
const util = require("util");
// @ts-ignore no implicit any
const protos = require("fabric-protos");
function newFullBlockEvent(eventInfo) {
    if (!eventInfo.block) {
        throw new Error('No block data found: ' + util.inspect(eventInfo));
    }
    let transactionEvents;
    function getTransactionEvents(block) {
        if (!transactionEvents) {
            transactionEvents = newFullTransactionEvents(block);
        }
        return transactionEvents;
    }
    const blockEvent = {
        type: 'full',
        blockNumber: eventInfo.blockNumber,
        blockData: eventInfo.block,
        getTransactionEvents: () => getTransactionEvents(blockEvent)
    };
    return Object.freeze(blockEvent);
}
exports.newFullBlockEvent = newFullBlockEvent;
function newFullTransactionEvents(blockEvent) {
    const txEnvelopeIndexes = [];
    const envelopes = blockEvent.blockData.data.data || [];
    envelopes.forEach((envelope, index) => {
        if (isTransactionPayload(envelope.payload)) {
            txEnvelopeIndexes.push(index);
        }
    });
    return txEnvelopeIndexes.map((index) => newFullTransactionEvent(blockEvent, index));
}
function isTransactionPayload(payload) {
    return payload.header.channel_header.type === protos.common.HeaderType.ENDORSER_TRANSACTION;
}
function newFullTransactionEvent(blockEvent, txEnvelopeIndex) {
    const blockMetadata = blockEvent.blockData.metadata.metadata || [];
    const transactionStatusCodes = blockMetadata[protos.common.BlockMetadataIndex.TRANSACTIONS_FILTER];
    const envelope = blockEvent.blockData.data.data[txEnvelopeIndex];
    const transactionId = envelope.payload.header.channel_header.tx_id;
    const code = transactionStatusCodes[txEnvelopeIndex];
    const status = TransactionStatus.getStatusForCode(code);
    let contractEvents;
    function getContractEvents(transaction) {
        if (!contractEvents) {
            contractEvents = newFullContractEvents(transaction);
        }
        return contractEvents;
    }
    const transactionEvent = {
        type: 'full',
        transactionId,
        status,
        transactionData: envelope.payload.data,
        isValid: status === TransactionStatus.VALID_STATUS,
        getBlockEvent: () => blockEvent,
        getContractEvents: () => getContractEvents(transactionEvent)
    };
    return Object.freeze(transactionEvent);
}
function newFullContractEvents(transactionEvent) {
    const transactionActions = transactionEvent.transactionData.actions || [];
    return transactionActions.map((transactionAction) => {
        const chaincodeEvent = transactionAction.payload.action.proposal_response_payload.extension.events;
        return newFullContractEvent(transactionEvent, chaincodeEvent);
    });
}
function newFullContractEvent(transactionEvent, chaincodeEvent) {
    const contractEvent = {
        type: 'full',
        chaincodeId: chaincodeEvent.chaincode_id,
        eventName: chaincodeEvent.event_name,
        payload: chaincodeEvent.payload,
        getTransactionEvent: () => transactionEvent
    };
    return Object.freeze(contractEvent);
}
//# sourceMappingURL=fulleventfactory.js.map